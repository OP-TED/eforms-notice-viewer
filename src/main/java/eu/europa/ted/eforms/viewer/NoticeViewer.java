package eu.europa.ted.eforms.viewer;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.MessageFormat;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.SAXException;
import eu.europa.ted.eforms.sdk.SdkConstants;
import eu.europa.ted.eforms.sdk.resource.SdkResourceLoader;
import eu.europa.ted.eforms.viewer.generator.HtmlGenerator;
import eu.europa.ted.eforms.viewer.generator.XslGenerator;
import eu.europa.ted.efx.EfxTranslator;
import eu.europa.ted.efx.interfaces.TranslatorOptions;

public class NoticeViewer {
  private static final Logger logger = LoggerFactory.getLogger(NoticeViewer.class);

  private static final String MSG_UNDEFINED_NOTICE_DOCUMENT = "Undefined notice document";

  private XslGenerator xslGenerator;
  private HtmlGenerator htmlGenerator;

  private NoticeViewer(final DependencyFactory dependencyFactory,
      final TranslatorOptions translatorOptions, final Charset charset, final boolean profileXslt,
      final URIResolver uriResolver) {
    this.xslGenerator =
        XslGenerator.Builder.create(dependencyFactory)
            .withTranslatorOptions(translatorOptions)
            .build();

    this.htmlGenerator = HtmlGenerator.Builder
        .create()
        .withCharset(charset)
        .withProfileXslt(profileXslt)
        .withUriResolver(uriResolver)
        .build();
  }

  /**
   * Creates a HTML file with the contents generated by applying XSL transformation on a notice's
   * XML using a XSL template.
   * <p>
   * This XSL template is generated internally, based on SDK files.
   * <p>
   * The SDK root directory is expected to contain a directory per minor SDK version.
   *
   * @param language The language as a two letter code
   * @param viewId An optional SDK view id to used for loading the corresponding EFX template.
   *        <p>
   *        This can be used to enforce a custom view like notice summary. It could fail if this
   *        custom view is not compatible with the notice sub type.
   *        <p>
   *        If not given, then the notice sub type ID from the notice XML will be used.
   * @param notice A {@link NoticeDocument} object containing the notice's XML contents and metadata
   * @return The path of the generated HTML file
   * @param sdkRoot Path of the root SDK directory
   * @param forceBuild If true, forces the re-creation of XSL (re-creates cache entries)
   * @return The path of the generated HTML file
   * @throws IOException when the XML/XSL contents cannot be loaded
   * @throws TransformerException when the XSL transformation fails
   * @throws SAXException when the notice XML cannot be parsed
   * @throws ParserConfigurationException when the XML parser is not configured properly
   */
  public Path generateHtmlFile(final String language, String viewId, final NoticeDocument notice,
      final Path outputFile, final Path sdkRoot, boolean forceBuild)
      throws IOException, TransformerException, ParserConfigurationException, SAXException {
    Validate.notNull(notice, MSG_UNDEFINED_NOTICE_DOCUMENT);

    final String sdkVersion = notice.getEformsSdkVersion();
    viewId = ObjectUtils.defaultIfNull(viewId, notice.getNoticeSubType());

    final Path efxPath = getEfxPath(sdkVersion, viewId, sdkRoot);

    logger.debug("Starting XSL generation using the EFX template at [{}]", efxPath);
    final String xslContents = xslGenerator.generateString(sdkVersion, viewId, efxPath, forceBuild);

    return generateHtmlFile(language, viewId, notice, xslContents, outputFile);
  }

  /**
   * Creates a HTML file with the contents generated by applying XSL transformation on a notice's
   * XML using a XSL template.
   * 
   * @param language The language as a two letter code
   * @param viewId The view ID corresponding to the XSL template.
   * @param notice A {@link NoticeDocument} object containing the notice's XML contents and metadata
   * @param xslContents The contents of the XSL template
   * @param outputFile The path of the generated HTML file
   * @return The path of the generated HTML file
   * @throws IOException when the XML/XSL contents cannot be loaded
   * @throws TransformerException when the XSL transformation fails
   */
  public Path generateHtmlFile(final String language, final String viewId,
      final NoticeDocument notice, final String xslContents, Path outputFile)
      throws IOException, TransformerException {
    Validate.notNull(notice, MSG_UNDEFINED_NOTICE_DOCUMENT);

    if (outputFile == null) {
      outputFile = NoticeViewerConstants.OUTPUT_FOLDER_HTML
          .resolve(MessageFormat.format("{0}-{1}.html", viewId, language));
    }

    Files.createDirectories(outputFile.getParent());

    return htmlGenerator.generateFile(language, viewId, notice.getXmlContents(), xslContents,
        outputFile);
  }

  /**
   * Generates HTML by applying XSL transformation on a notice's XML using a XSL template.
   * <p>
   * This XSL template is generated internally, based on SDK files.
   * <p>
   * The SDK root directory is expected to contain a directory per minor SDK version.
   *
   * @param language The language as a two letter code
   * @param viewId An optional SDK view id to used for loading the corresponding EFX template.
   *        <p>
   *        This can be used to enforce a custom view like notice summary. It could fail if this
   *        custom view is not compatible with the notice sub type.
   *        <p>
   *        If not given, then the notice sub type ID from the notice XML will be used.
   * @param notice A {@link NoticeDocument} object containing the notice's XML contents and metadata
   * @param sdkRoot Path of the root SDK directory
   * @param forceBuild If true, forces the re-creation of XSL (re-creates cache entries)
   * @return Generated HTML as {@link String}
   * @throws TransformerException when the XSL transformation fails
   * @throws IOException when the XML/XSL contents cannot be loaded
   * @throws SAXException when the notice XML cannot be parsed
   * @throws ParserConfigurationException when the XML parser is not configured properly
   */
  public String generateHtmlString(final String language, String viewId,
      final NoticeDocument notice, final Path sdkRoot, boolean forceBuild)
      throws TransformerException, IOException, ParserConfigurationException, SAXException {
    Validate.notNull(notice, MSG_UNDEFINED_NOTICE_DOCUMENT);

    final String sdkVersion = notice.getEformsSdkVersion();
    viewId = ObjectUtils.defaultIfNull(viewId, notice.getNoticeSubType());

    final Path efxPath = getEfxPath(sdkVersion, viewId, sdkRoot);

    logger.debug("Starting XSL generation using the EFX template at [{}]", efxPath);
    final String xslContents = xslGenerator.generateString(sdkVersion, viewId, efxPath, forceBuild);

    return generateHtmlString(language, viewId, notice, xslContents);
  }

  /**
   * Generates HTML by applying XSL transformation on a notice's XML using a XSL template.
   *
   * @param language The language as a two letter code
   * @param viewId The view ID corresponding to the XSL template.
   * @param notice A {@link NoticeDocument} object containing the notice's XML contents and metadata
   * @param xslContents The contents of the XSL template
   * @return Generated HTML as {@link String}
   * @throws TransformerException when the XSL transformation fails
   * @throws IOException when the XML/XSL contents cannot be loaded
   */
  public String generateHtmlString(final String language, final String viewId,
      final NoticeDocument notice, final String xslContents)
      throws TransformerException, IOException {
    Validate.notNull(notice, MSG_UNDEFINED_NOTICE_DOCUMENT);

    logger.info("Generating HTML for language [{}] and view ID [{}]", language, viewId);

    final String html =
        htmlGenerator.generateString(language, viewId, notice.getXmlContents(), xslContents);

    logger.info("Finished generating HTML for language [{}] and view ID [{}]", language, viewId);

    return html;
  }

  private NoticeViewer(Builder builder) {
    this(builder.dependencyFactory, builder.translatorOptions, builder.charset, builder.profileXslt,
        builder.uriResolver);
  }

  /**
   * Resolves the path of the EFX template for a view.
   *
   * @param sdkVersion The target SDK version
   * @param viewId The view ID to use for finding the EFX template file
   * @param sdkRoot Path of the root SDK folder
   * @return The path of the EFX template
   * @throws FileNotFoundException when the resolved EFX path does not point to an existing file
   */
  public static Path getEfxPath(final String sdkVersion, final String viewId, final Path sdkRoot)
      throws FileNotFoundException {
    Path efxPath = SdkResourceLoader.getResourceAsPath(sdkVersion,
        SdkConstants.SdkResource.VIEW_TEMPLATES, MessageFormat.format("{0}.efx", viewId), sdkRoot);

    Validate.notNull(efxPath,
        "Failed to create EFX path for view ID [{}], SDK version [{}] and SDK root directory [{}]",
        viewId, sdkVersion, sdkRoot);

    if (!Files.isRegularFile(efxPath)) {
      throw new FileNotFoundException(efxPath.toString());
    }

    logger.debug("EFX path for view ID {} and SDK {}: {}", viewId, sdkVersion, efxPath);

    return efxPath;
  }

  /**
   * Builder class for {@link NoticeViewer} instances
   */
  public static final class Builder {
    // required parameters
    private final DependencyFactory dependencyFactory;

    // optional parameters
    private Charset charset;
    private boolean profileXslt;
    private TranslatorOptions translatorOptions;
    private URIResolver uriResolver;

    /**
     * @param dependencyFactory The dependency factory to provide to
     *        {@link EfxTranslator#translateExpression} method
     */
    public Builder(final DependencyFactory dependencyFactory) {
      this.dependencyFactory = dependencyFactory;
    }

    public static Builder create(final DependencyFactory dependencyFactory) {
      return new Builder(dependencyFactory);
    }

    /**
     * @param charset The character set to be used for the HTML output and for reading the XSL
     *        template and the notice XML
     * @return A {@link Builder} instance
     */
    public Builder withCharset(final Charset charset) {
      this.charset = charset;
      return this;
    }

    /**
     * @param profileXslt If true, Enables XSLT profiling
     * @return A {@link Builder} instance
     */
    public Builder withProfileXslt(final boolean profileXslt) {
      this.profileXslt = profileXslt;
      return this;
    }

    /**
     * @param translatorOptions A {@link TranslatorOptions} instance with configuration for the
     *        translation
     * @return A {@link Builder} instance
     */
    public Builder withTranslatorOptions(final TranslatorOptions translatorOptions) {
      this.translatorOptions = translatorOptions;
      return this;
    }

    /**
     * @param uriResolver The URI resolver to be used during the XSL transformation
     * @return A {@link Builder} instance
     */
    public Builder withUriResolver(URIResolver uriResolver) {
      this.uriResolver = uriResolver;
      return this;
    }

    /**
     * @return A configured {@link NoticeViewer} instance
     */
    public NoticeViewer build() {
      return new NoticeViewer(this);
    }
  }
}
